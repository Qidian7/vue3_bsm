{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Path = require(\"zrender/lib/graphic/Path\");\nvar vec2 = require(\"zrender/lib/core/vector\");\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n      break;\n    }\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n    prevIdx = idx;\n    idx += dir;\n  }\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n      break;\n    }\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n    prevIdx = idx;\n    idx += dir;\n  }\n  return k;\n}\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","map":{"version":3,"names":["Path","require","vec2","fixClipWithShadow","vec2Min","min","vec2Max","max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","drawNonMono","apply","arguments","drawMono","prevIdx","idx","k","prevP","dim","ctrlLen","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","sub","lenPrevSeg","lenNextSeg","Math","abs","dist","getBoundingBox","smoothConstraint","ptMin","Infinity","ptMax","i","length","pt","Polyline","extend","type","shape","style","fill","stroke","brush","prototype","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/chart/line/poly.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}