{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\nvar _task = require(\"./task\");\nvar createTask = _task.createTask;\nvar _component = require(\"../util/component\");\nvar getUID = _component.getUID;\nvar GlobalModel = require(\"../model/Global\");\nvar ExtensionAPI = require(\"../ExtensionAPI\");\nvar _model = require(\"../util/model\");\nvar normalizeToArray = _model.normalizeToArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n  scheduler.unfinished |= unfinished;\n}\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n      task = task.getUpstream();\n    } while (task);\n  });\n};\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n    overallProgress = false;\n    each(ecModel.getSeries(), createStub);\n  }\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n  return seriesType;\n}\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;","map":{"version":3,"names":["_util","require","each","map","isFunction","createHashMap","noop","_task","createTask","_component","getUID","GlobalModel","ExtensionAPI","_model","normalizeToArray","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","unfinished","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","_stageTaskMap","proto","prototype","restoreData","ecModel","payload","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","reset","createSeriesStageTask","overallReset","createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","performStageTasks","block","performVisualTasks","opt","stageHandlers","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty","agentStubMap","stub","needSetDirty","updatePayload","performArgs","perform","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","dispose","removeKey","overallTaskReset","overallProgress","modifyOutputEnd","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","upstreamContext","stubProgress","getDownstream","clearAllVisual","resetDefines","length","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","wrapStageHandler","detectSeriseType","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/stream/Scheduler.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n      overallProgress = false;\n      each(ecModel.getSeries(), createStub);\n    }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}