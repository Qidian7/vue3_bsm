{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar Group = require(\"../container/Group\");\nvar ZImage = require(\"../graphic/Image\");\nvar Text = require(\"../graphic/Text\");\nvar Circle = require(\"../graphic/shape/Circle\");\nvar Rect = require(\"../graphic/shape/Rect\");\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\nvar Line = require(\"../graphic/shape/Line\");\nvar Path = require(\"../graphic/Path\");\nvar Polygon = require(\"../graphic/shape/Polygon\");\nvar Polyline = require(\"../graphic/shape/Polyline\");\nvar LinearGradient = require(\"../graphic/LinearGradient\");\nvar Style = require(\"../graphic/Style\");\nvar matrix = require(\"../core/matrix\");\nvar _path = require(\"./path\");\nvar createFromString = _path.createFromString;\nvar _util = require(\"../core/util\");\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each;\n// import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n  return svg;\n}\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n  while (child) {\n    this._parseNode(child, root);\n    child = child.nextSibling;\n  }\n  var viewBoxRect;\n  var viewBoxTransform;\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n  var el;\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n  var child = xmlNode.firstChild;\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n    child = child.nextSibling;\n  } // Quit define\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n    if (points) {\n      points = parsePoints(points);\n    }\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n    if (points) {\n      points = parsePoints(points);\n    }\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n    _parseGradientColorStops(xmlNode, gradient);\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n    stop = stop.nextSibling;\n  }\n}\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n  return points;\n}\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n  el.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n  return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n  if (!style) {\n    return result;\n  }\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;","map":{"version":3,"names":["Group","require","ZImage","Text","Circle","Rect","Ellipse","Line","Path","Polygon","Polyline","LinearGradient","Style","matrix","_path","createFromString","_util","isString","extend","defaults","trim","each","DILIMITER_REG","parseXML","svg","parser","DOMParser","parseFromString","nodeType","firstChild","nodeName","toLowerCase","nextSibling","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scale","slice","position","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","nodeParsers","_parseText","dx","dy","_textX","_textY","text","style","textContent","transformText","inheritStyle","fontSize","rect","getBoundingRect","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","polygon","points","parsePoints","polyline","path","image","img","setStyle","tspan","d","lineargradient","parseInt","gradient","_parseGradientColorStops","radialgradient","stop","offset","indexOf","stopColor","addColorStop","parent","__inheritedStyle","pointsString","list","i","push","attributesMap","defs","onlyInlineStyle","zrStyle","isTextEl","type","parseTransformAttribute","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","elFillProp","elStrokeProp","elStyle","fill","set","getPaint","stroke","propName","elPropName","textBaseline","textAlign","lineDash","urlRegex","str","urlMatch","match","url","transformRegex","node","transform","replace","m","transformOps","value","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","scaleX","scaleY","Math","min","viewBoxScale","viewBoxPosition","parseSVG","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/zrender/lib/tool/parseSVG.js"],"sourcesContent":["var Group = require(\"../container/Group\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar _path = require(\"./path\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each;\n// import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;"],"mappings":";AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAEzC,IAAIC,MAAM,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAExC,IAAIE,IAAI,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAErC,IAAIG,MAAM,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAE/C,IAAII,IAAI,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAE3C,IAAIK,OAAO,GAAGL,OAAO,CAAC,0BAA0B,CAAC;AAEjD,IAAIM,IAAI,GAAGN,OAAO,CAAC,uBAAuB,CAAC;AAE3C,IAAIO,IAAI,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAErC,IAAIQ,OAAO,GAAGR,OAAO,CAAC,0BAA0B,CAAC;AAEjD,IAAIS,QAAQ,GAAGT,OAAO,CAAC,2BAA2B,CAAC;AAEnD,IAAIU,cAAc,GAAGV,OAAO,CAAC,2BAA2B,CAAC;AAEzD,IAAIW,KAAK,GAAGX,OAAO,CAAC,kBAAkB,CAAC;AAEvC,IAAIY,MAAM,GAAGZ,OAAO,CAAC,gBAAgB,CAAC;AAEtC,IAAIa,KAAK,GAAGb,OAAO,CAAC,QAAQ,CAAC;AAE7B,IAAIc,gBAAgB,GAAGD,KAAK,CAACC,gBAAgB;AAE7C,IAAIC,KAAK,GAAGf,OAAO,CAAC,cAAc,CAAC;AAEnC,IAAIgB,QAAQ,GAAGD,KAAK,CAACC,QAAQ;AAC7B,IAAIC,MAAM,GAAGF,KAAK,CAACE,MAAM;AACzB,IAAIC,QAAQ,GAAGH,KAAK,CAACG,QAAQ;AAC7B,IAAIC,IAAI,GAAGJ,KAAK,CAACI,IAAI;AACrB,IAAIC,IAAI,GAAGL,KAAK,CAACK,IAAI;AACrB;AACA;AACA;AACA;AACA,IAAIC,aAAa,GAAG,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,QAAQA,CAACC,GAAG,EAAE;EACrB,IAAIP,QAAQ,CAACO,GAAG,CAAC,EAAE;IACjB,IAAIC,MAAM,GAAG,IAAIC,SAAS,EAAE;IAC5BF,GAAG,GAAGC,MAAM,CAACE,eAAe,CAACH,GAAG,EAAE,UAAU,CAAC;EAC/C,CAAC,CAAC;;EAGF,IAAIA,GAAG,CAACI,QAAQ,KAAK,CAAC,EAAE;IACtBJ,GAAG,GAAGA,GAAG,CAACK,UAAU;EACtB,CAAC,CAAC;;EAGF,OAAOL,GAAG,CAACM,QAAQ,CAACC,WAAW,EAAE,KAAK,KAAK,IAAIP,GAAG,CAACI,QAAQ,KAAK,CAAC,EAAE;IACjEJ,GAAG,GAAGA,GAAG,CAACQ,WAAW;EACvB;EAEA,OAAOR,GAAG;AACZ;AAEA,SAASS,SAASA,CAAA,EAAG;EACnB,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;EACf,IAAI,CAACC,KAAK,GAAG,IAAI;EACjB,IAAI,CAACC,SAAS,GAAG,KAAK;EACtB,IAAI,CAACC,OAAO,GAAG,KAAK;AACtB;AAEAJ,SAAS,CAACK,SAAS,CAACC,KAAK,GAAG,UAAUC,GAAG,EAAEC,GAAG,EAAE;EAC9CA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;EACf,IAAIjB,GAAG,GAAGD,QAAQ,CAACiB,GAAG,CAAC;EAEvB,IAAI,CAAChB,GAAG,EAAE;IACR,MAAM,IAAIkB,KAAK,CAAC,aAAa,CAAC;EAChC;EAEA,IAAIC,IAAI,GAAG,IAAI3C,KAAK,EAAE;EACtB,IAAI,CAACmC,KAAK,GAAGQ,IAAI,CAAC,CAAC;;EAEnB,IAAIC,OAAO,GAAGpB,GAAG,CAACqB,YAAY,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;EACjD;;EAEA,IAAIC,KAAK,GAAGC,UAAU,CAACvB,GAAG,CAACqB,YAAY,CAAC,OAAO,CAAC,IAAIJ,GAAG,CAACK,KAAK,CAAC;EAC9D,IAAIE,MAAM,GAAGD,UAAU,CAACvB,GAAG,CAACqB,YAAY,CAAC,QAAQ,CAAC,IAAIJ,GAAG,CAACO,MAAM,CAAC,CAAC,CAAC;;EAEnEC,KAAK,CAACH,KAAK,CAAC,KAAKA,KAAK,GAAG,IAAI,CAAC;EAC9BG,KAAK,CAACD,MAAM,CAAC,KAAKA,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC;;EAElCE,eAAe,CAAC1B,GAAG,EAAEmB,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;EACtC,IAAIQ,KAAK,GAAG3B,GAAG,CAACK,UAAU;EAE1B,OAAOsB,KAAK,EAAE;IACZ,IAAI,CAACC,UAAU,CAACD,KAAK,EAAER,IAAI,CAAC;IAE5BQ,KAAK,GAAGA,KAAK,CAACnB,WAAW;EAC3B;EAEA,IAAIqB,WAAW;EACf,IAAIC,gBAAgB;EAEpB,IAAIV,OAAO,EAAE;IACX,IAAIW,UAAU,GAAGnC,IAAI,CAACwB,OAAO,CAAC,CAACY,KAAK,CAAClC,aAAa,CAAC,CAAC,CAAC;;IAErD,IAAIiC,UAAU,CAACE,MAAM,IAAI,CAAC,EAAE;MAC1BJ,WAAW,GAAG;QACZK,CAAC,EAAEX,UAAU,CAACQ,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACjCI,CAAC,EAAEZ,UAAU,CAACQ,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACjCT,KAAK,EAAEC,UAAU,CAACQ,UAAU,CAAC,CAAC,CAAC,CAAC;QAChCP,MAAM,EAAED,UAAU,CAACQ,UAAU,CAAC,CAAC,CAAC;MAClC,CAAC;IACH;EACF;EAEA,IAAIF,WAAW,IAAIP,KAAK,IAAI,IAAI,IAAIE,MAAM,IAAI,IAAI,EAAE;IAClDM,gBAAgB,GAAGM,oBAAoB,CAACP,WAAW,EAAEP,KAAK,EAAEE,MAAM,CAAC;IAEnE,IAAI,CAACP,GAAG,CAACoB,aAAa,EAAE;MACtB;MACA;MACA;MACA;MACA;MACA;MACA,IAAIC,MAAM,GAAGnB,IAAI;MACjBA,IAAI,GAAG,IAAI3C,KAAK,EAAE;MAClB2C,IAAI,CAACoB,GAAG,CAACD,MAAM,CAAC;MAChBA,MAAM,CAACE,KAAK,GAAGV,gBAAgB,CAACU,KAAK,CAACC,KAAK,EAAE;MAC7CH,MAAM,CAACI,QAAQ,GAAGZ,gBAAgB,CAACY,QAAQ,CAACD,KAAK,EAAE;IACrD;EACF,CAAC,CAAC;EACF;;EAGA,IAAI,CAACxB,GAAG,CAAC0B,cAAc,IAAIrB,KAAK,IAAI,IAAI,IAAIE,MAAM,IAAI,IAAI,EAAE;IAC1DL,IAAI,CAACyB,WAAW,CAAC,IAAI/D,IAAI,CAAC;MACxBgE,KAAK,EAAE;QACLX,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAAC;QACJb,KAAK,EAAEA,KAAK;QACZE,MAAM,EAAEA;MACV;IACF,CAAC,CAAC,CAAC;EACL,CAAC,CAAC;;EAGF,OAAO;IACLL,IAAI,EAAEA,IAAI;IACVG,KAAK,EAAEA,KAAK;IACZE,MAAM,EAAEA,MAAM;IACdK,WAAW,EAAEA,WAAW;IACxBC,gBAAgB,EAAEA;EACpB,CAAC;AACH,CAAC;AAEDrB,SAAS,CAACK,SAAS,CAACc,UAAU,GAAG,UAAUkB,OAAO,EAAEC,WAAW,EAAE;EAC/D,IAAIzC,QAAQ,GAAGwC,OAAO,CAACxC,QAAQ,CAACC,WAAW,EAAE,CAAC,CAAC;EAC/C;EACA;;EAEA,IAAID,QAAQ,KAAK,MAAM,EAAE;IACvB;IACA,IAAI,CAACM,SAAS,GAAG,IAAI;EACvB,CAAC,MAAM,IAAIN,QAAQ,KAAK,MAAM,EAAE;IAC9B,IAAI,CAACO,OAAO,GAAG,IAAI;EACrB;EAEA,IAAImC,EAAE;EAEN,IAAI,IAAI,CAACpC,SAAS,EAAE;IAClB,IAAIX,MAAM,GAAGgD,aAAa,CAAC3C,QAAQ,CAAC;IAEpC,IAAIL,MAAM,EAAE;MACV,IAAIiD,GAAG,GAAGjD,MAAM,CAACkD,IAAI,CAAC,IAAI,EAAEL,OAAO,CAAC;MACpC,IAAIM,EAAE,GAAGN,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC;MAEnC,IAAI+B,EAAE,EAAE;QACN,IAAI,CAAC1C,KAAK,CAAC0C,EAAE,CAAC,GAAGF,GAAG;MACtB;IACF;EACF,CAAC,MAAM;IACL,IAAIjD,MAAM,GAAGoD,WAAW,CAAC/C,QAAQ,CAAC;IAElC,IAAIL,MAAM,EAAE;MACV+C,EAAE,GAAG/C,MAAM,CAACkD,IAAI,CAAC,IAAI,EAAEL,OAAO,EAAEC,WAAW,CAAC;MAC5CA,WAAW,CAACR,GAAG,CAACS,EAAE,CAAC;IACrB;EACF;EAEA,IAAIrB,KAAK,GAAGmB,OAAO,CAACzC,UAAU;EAE9B,OAAOsB,KAAK,EAAE;IACZ,IAAIA,KAAK,CAACvB,QAAQ,KAAK,CAAC,EAAE;MACxB,IAAI,CAACwB,UAAU,CAACD,KAAK,EAAEqB,EAAE,CAAC;IAC5B,CAAC,CAAC;;IAGF,IAAIrB,KAAK,CAACvB,QAAQ,KAAK,CAAC,IAAI,IAAI,CAACS,OAAO,EAAE;MACxC,IAAI,CAACyC,UAAU,CAAC3B,KAAK,EAAEqB,EAAE,CAAC;IAC5B;IAEArB,KAAK,GAAGA,KAAK,CAACnB,WAAW;EAC3B,CAAC,CAAC;;EAGF,IAAIF,QAAQ,KAAK,MAAM,EAAE;IACvB,IAAI,CAACM,SAAS,GAAG,KAAK;EACxB,CAAC,MAAM,IAAIN,QAAQ,KAAK,MAAM,EAAE;IAC9B,IAAI,CAACO,OAAO,GAAG,KAAK;EACtB;AACF,CAAC;AAEDJ,SAAS,CAACK,SAAS,CAACwC,UAAU,GAAG,UAAUR,OAAO,EAAEC,WAAW,EAAE;EAC/D,IAAID,OAAO,CAAC1C,QAAQ,KAAK,CAAC,EAAE;IAC1B,IAAImD,EAAE,GAAGT,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAImC,EAAE,GAAGV,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAI,CAACoC,MAAM,IAAIlC,UAAU,CAACgC,EAAE,CAAC;IAC7B,IAAI,CAACG,MAAM,IAAInC,UAAU,CAACiC,EAAE,CAAC;EAC/B;EAEA,IAAIG,IAAI,GAAG,IAAIhF,IAAI,CAAC;IAClBiF,KAAK,EAAE;MACLD,IAAI,EAAEb,OAAO,CAACe,WAAW;MACzBC,aAAa,EAAE;IACjB,CAAC;IACDpB,QAAQ,EAAE,CAAC,IAAI,CAACe,MAAM,IAAI,CAAC,EAAE,IAAI,CAACC,MAAM,IAAI,CAAC;EAC/C,CAAC,CAAC;EACFK,YAAY,CAAChB,WAAW,EAAEY,IAAI,CAAC;EAC/BjC,eAAe,CAACoB,OAAO,EAAEa,IAAI,EAAE,IAAI,CAACjD,KAAK,CAAC;EAC1C,IAAIsD,QAAQ,GAAGL,IAAI,CAACC,KAAK,CAACI,QAAQ;EAElC,IAAIA,QAAQ,IAAIA,QAAQ,GAAG,CAAC,EAAE;IAC5B;IACAL,IAAI,CAACC,KAAK,CAACI,QAAQ,GAAG,CAAC;IACvBL,IAAI,CAACnB,KAAK,GAAGmB,IAAI,CAACnB,KAAK,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;IACjCmB,IAAI,CAACnB,KAAK,CAAC,CAAC,CAAC,IAAIwB,QAAQ,GAAG,CAAC;IAC7BL,IAAI,CAACnB,KAAK,CAAC,CAAC,CAAC,IAAIwB,QAAQ,GAAG,CAAC;EAC/B;EAEA,IAAIC,IAAI,GAAGN,IAAI,CAACO,eAAe,EAAE;EACjC,IAAI,CAACT,MAAM,IAAIQ,IAAI,CAAC3C,KAAK;EACzByB,WAAW,CAACR,GAAG,CAACoB,IAAI,CAAC;EACrB,OAAOA,IAAI;AACb,CAAC;AAED,IAAIN,WAAW,GAAG;EAChB,GAAG,EAAE,SAAAc,CAAUrB,OAAO,EAAEC,WAAW,EAAE;IACnC,IAAIoB,CAAC,GAAG,IAAI3F,KAAK,EAAE;IACnBuF,YAAY,CAAChB,WAAW,EAAEoB,CAAC,CAAC;IAC5BzC,eAAe,CAACoB,OAAO,EAAEqB,CAAC,EAAE,IAAI,CAACzD,KAAK,CAAC;IACvC,OAAOyD,CAAC;EACV,CAAC;EACD,MAAM,EAAE,SAAAF,CAAUnB,OAAO,EAAEC,WAAW,EAAE;IACtC,IAAIkB,IAAI,GAAG,IAAIpF,IAAI,EAAE;IACrBkF,YAAY,CAAChB,WAAW,EAAEkB,IAAI,CAAC;IAC/BvC,eAAe,CAACoB,OAAO,EAAEmB,IAAI,EAAE,IAAI,CAACvD,KAAK,CAAC;IAC1CuD,IAAI,CAACG,QAAQ,CAAC;MACZlC,CAAC,EAAEX,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;MAC7Cc,CAAC,EAAEZ,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;MAC7CC,KAAK,EAAEC,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;MACrDG,MAAM,EAAED,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC;IACxD,CAAC,CAAC,CAAC,CAAC;IACJ;;IAEA,OAAO4C,IAAI;EACb,CAAC;EACD,QAAQ,EAAE,SAAAI,CAAUvB,OAAO,EAAEC,WAAW,EAAE;IACxC,IAAIsB,MAAM,GAAG,IAAIzF,MAAM,EAAE;IACzBmF,YAAY,CAAChB,WAAW,EAAEsB,MAAM,CAAC;IACjC3C,eAAe,CAACoB,OAAO,EAAEuB,MAAM,EAAE,IAAI,CAAC3D,KAAK,CAAC;IAC5C2D,MAAM,CAACD,QAAQ,CAAC;MACdE,EAAE,EAAE/C,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CkD,EAAE,EAAEhD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CmD,CAAC,EAAEjD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;IAC9C,CAAC,CAAC;IACF,OAAOgD,MAAM;EACf,CAAC;EACD,MAAM,EAAE,SAAAI,CAAU3B,OAAO,EAAEC,WAAW,EAAE;IACtC,IAAI0B,IAAI,GAAG,IAAI1F,IAAI,EAAE;IACrBgF,YAAY,CAAChB,WAAW,EAAE0B,IAAI,CAAC;IAC/B/C,eAAe,CAACoB,OAAO,EAAE2B,IAAI,EAAE,IAAI,CAAC/D,KAAK,CAAC;IAC1C+D,IAAI,CAACL,QAAQ,CAAC;MACZM,EAAE,EAAEnD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CsD,EAAE,EAAEpD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CuD,EAAE,EAAErD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CwD,EAAE,EAAEtD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IAChD,CAAC,CAAC;IACF,OAAOoD,IAAI;EACb,CAAC;EACD,SAAS,EAAE,SAAAK,CAAUhC,OAAO,EAAEC,WAAW,EAAE;IACzC,IAAI+B,OAAO,GAAG,IAAIhG,OAAO,EAAE;IAC3BiF,YAAY,CAAChB,WAAW,EAAE+B,OAAO,CAAC;IAClCpD,eAAe,CAACoB,OAAO,EAAEgC,OAAO,EAAE,IAAI,CAACpE,KAAK,CAAC;IAC7CoE,OAAO,CAACV,QAAQ,CAAC;MACfE,EAAE,EAAE/C,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/CkD,EAAE,EAAEhD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/C0D,EAAE,EAAExD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/C2D,EAAE,EAAEzD,UAAU,CAACuB,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IAChD,CAAC,CAAC;IACF,OAAOyD,OAAO;EAChB,CAAC;EACD,SAAS,EAAE,SAAAG,CAAUnC,OAAO,EAAEC,WAAW,EAAE;IACzC,IAAImC,MAAM,GAAGpC,OAAO,CAACzB,YAAY,CAAC,QAAQ,CAAC;IAE3C,IAAI6D,MAAM,EAAE;MACVA,MAAM,GAAGC,WAAW,CAACD,MAAM,CAAC;IAC9B;IAEA,IAAID,OAAO,GAAG,IAAIhG,OAAO,CAAC;MACxB4D,KAAK,EAAE;QACLqC,MAAM,EAAEA,MAAM,IAAI;MACpB;IACF,CAAC,CAAC;IACFnB,YAAY,CAAChB,WAAW,EAAEkC,OAAO,CAAC;IAClCvD,eAAe,CAACoB,OAAO,EAAEmC,OAAO,EAAE,IAAI,CAACvE,KAAK,CAAC;IAC7C,OAAOuE,OAAO;EAChB,CAAC;EACD,UAAU,EAAE,SAAAG,CAAUtC,OAAO,EAAEC,WAAW,EAAE;IAC1C,IAAIsC,IAAI,GAAG,IAAIrG,IAAI,EAAE;IACrB+E,YAAY,CAAChB,WAAW,EAAEsC,IAAI,CAAC;IAC/B3D,eAAe,CAACoB,OAAO,EAAEuC,IAAI,EAAE,IAAI,CAAC3E,KAAK,CAAC;IAC1C,IAAIwE,MAAM,GAAGpC,OAAO,CAACzB,YAAY,CAAC,QAAQ,CAAC;IAE3C,IAAI6D,MAAM,EAAE;MACVA,MAAM,GAAGC,WAAW,CAACD,MAAM,CAAC;IAC9B;IAEA,IAAIE,QAAQ,GAAG,IAAIlG,QAAQ,CAAC;MAC1B2D,KAAK,EAAE;QACLqC,MAAM,EAAEA,MAAM,IAAI;MACpB;IACF,CAAC,CAAC;IACF,OAAOE,QAAQ;EACjB,CAAC;EACD,OAAO,EAAE,SAAAE,CAAUxC,OAAO,EAAEC,WAAW,EAAE;IACvC,IAAIwC,GAAG,GAAG,IAAI7G,MAAM,EAAE;IACtBqF,YAAY,CAAChB,WAAW,EAAEwC,GAAG,CAAC;IAC9B7D,eAAe,CAACoB,OAAO,EAAEyC,GAAG,EAAE,IAAI,CAAC7E,KAAK,CAAC;IACzC6E,GAAG,CAACC,QAAQ,CAAC;MACXF,KAAK,EAAExC,OAAO,CAACzB,YAAY,CAAC,YAAY,CAAC;MACzCa,CAAC,EAAEY,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC;MAC5Bc,CAAC,EAAEW,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC;MAC5BC,KAAK,EAAEwB,OAAO,CAACzB,YAAY,CAAC,OAAO,CAAC;MACpCG,MAAM,EAAEsB,OAAO,CAACzB,YAAY,CAAC,QAAQ;IACvC,CAAC,CAAC;IACF,OAAOkE,GAAG;EACZ,CAAC;EACD,MAAM,EAAE,SAAA5B,CAAUb,OAAO,EAAEC,WAAW,EAAE;IACtC,IAAIb,CAAC,GAAGY,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;IACtC,IAAIc,CAAC,GAAGW,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;IACtC,IAAIkC,EAAE,GAAGT,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAImC,EAAE,GAAGV,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAI,CAACoC,MAAM,GAAGlC,UAAU,CAACW,CAAC,CAAC,GAAGX,UAAU,CAACgC,EAAE,CAAC;IAC5C,IAAI,CAACG,MAAM,GAAGnC,UAAU,CAACY,CAAC,CAAC,GAAGZ,UAAU,CAACiC,EAAE,CAAC;IAC5C,IAAIW,CAAC,GAAG,IAAI3F,KAAK,EAAE;IACnBuF,YAAY,CAAChB,WAAW,EAAEoB,CAAC,CAAC;IAC5BzC,eAAe,CAACoB,OAAO,EAAEqB,CAAC,EAAE,IAAI,CAACzD,KAAK,CAAC;IACvC,OAAOyD,CAAC;EACV,CAAC;EACD,OAAO,EAAE,SAAAsB,CAAU3C,OAAO,EAAEC,WAAW,EAAE;IACvC,IAAIb,CAAC,GAAGY,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC;IACjC,IAAIc,CAAC,GAAGW,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC;IAEjC,IAAIa,CAAC,IAAI,IAAI,EAAE;MACb;MACA,IAAI,CAACuB,MAAM,GAAGlC,UAAU,CAACW,CAAC,CAAC;IAC7B;IAEA,IAAIC,CAAC,IAAI,IAAI,EAAE;MACb;MACA,IAAI,CAACuB,MAAM,GAAGnC,UAAU,CAACY,CAAC,CAAC;IAC7B;IAEA,IAAIoB,EAAE,GAAGT,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAImC,EAAE,GAAGV,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAI8C,CAAC,GAAG,IAAI3F,KAAK,EAAE;IACnBuF,YAAY,CAAChB,WAAW,EAAEoB,CAAC,CAAC;IAC5BzC,eAAe,CAACoB,OAAO,EAAEqB,CAAC,EAAE,IAAI,CAACzD,KAAK,CAAC;IACvC,IAAI,CAAC+C,MAAM,IAAIF,EAAE;IACjB,IAAI,CAACG,MAAM,IAAIF,EAAE;IACjB,OAAOW,CAAC;EACV,CAAC;EACD,MAAM,EAAE,SAAAkB,CAAUvC,OAAO,EAAEC,WAAW,EAAE;IACtC;IACA;IACA;IACA,IAAI2C,CAAC,GAAG5C,OAAO,CAACzB,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;;IAEzC,IAAIgE,IAAI,GAAG9F,gBAAgB,CAACmG,CAAC,CAAC;IAC9B3B,YAAY,CAAChB,WAAW,EAAEsC,IAAI,CAAC;IAC/B3D,eAAe,CAACoB,OAAO,EAAEuC,IAAI,EAAE,IAAI,CAAC3E,KAAK,CAAC;IAC1C,OAAO2E,IAAI;EACb;AACF,CAAC;AACD,IAAIpC,aAAa,GAAG;EAClB,gBAAgB,EAAE,SAAA0C,CAAU7C,OAAO,EAAE;IACnC,IAAI4B,EAAE,GAAGkB,QAAQ,CAAC9C,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC;IACtD,IAAIsD,EAAE,GAAGiB,QAAQ,CAAC9C,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC;IACtD,IAAIuD,EAAE,GAAGgB,QAAQ,CAAC9C,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC;IACvD,IAAIwD,EAAE,GAAGe,QAAQ,CAAC9C,OAAO,CAACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC;IACtD,IAAIwE,QAAQ,GAAG,IAAI1G,cAAc,CAACuF,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IAEjDiB,wBAAwB,CAAChD,OAAO,EAAE+C,QAAQ,CAAC;IAE3C,OAAOA,QAAQ;EACjB,CAAC;EACD,gBAAgB,EAAE,SAAAE,CAAUjD,OAAO,EAAE,CAAC;AACxC,CAAC;AAED,SAASgD,wBAAwBA,CAAChD,OAAO,EAAE+C,QAAQ,EAAE;EACnD,IAAIG,IAAI,GAAGlD,OAAO,CAACzC,UAAU;EAE7B,OAAO2F,IAAI,EAAE;IACX,IAAIA,IAAI,CAAC5F,QAAQ,KAAK,CAAC,EAAE;MACvB,IAAI6F,MAAM,GAAGD,IAAI,CAAC3E,YAAY,CAAC,QAAQ,CAAC;MAExC,IAAI4E,MAAM,CAACC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;QAC3B;QACAD,MAAM,GAAGL,QAAQ,CAACK,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG;MACrC,CAAC,MAAM,IAAIA,MAAM,EAAE;QACjB;QACAA,MAAM,GAAG1E,UAAU,CAAC0E,MAAM,CAAC;MAC7B,CAAC,MAAM;QACLA,MAAM,GAAG,CAAC;MACZ;MAEA,IAAIE,SAAS,GAAGH,IAAI,CAAC3E,YAAY,CAAC,YAAY,CAAC,IAAI,SAAS;MAC5DwE,QAAQ,CAACO,YAAY,CAACH,MAAM,EAAEE,SAAS,CAAC;IAC1C;IAEAH,IAAI,GAAGA,IAAI,CAACxF,WAAW;EACzB;AACF;AAEA,SAASuD,YAAYA,CAACsC,MAAM,EAAE1E,KAAK,EAAE;EACnC,IAAI0E,MAAM,IAAIA,MAAM,CAACC,gBAAgB,EAAE;IACrC,IAAI,CAAC3E,KAAK,CAAC2E,gBAAgB,EAAE;MAC3B3E,KAAK,CAAC2E,gBAAgB,GAAG,CAAC,CAAC;IAC7B;IAEA3G,QAAQ,CAACgC,KAAK,CAAC2E,gBAAgB,EAAED,MAAM,CAACC,gBAAgB,CAAC;EAC3D;AACF;AAEA,SAASnB,WAAWA,CAACoB,YAAY,EAAE;EACjC,IAAIC,IAAI,GAAG5G,IAAI,CAAC2G,YAAY,CAAC,CAACvE,KAAK,CAAClC,aAAa,CAAC;EAClD,IAAIoF,MAAM,GAAG,EAAE;EAEf,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACvE,MAAM,EAAEwE,CAAC,IAAI,CAAC,EAAE;IACvC,IAAIvE,CAAC,GAAGX,UAAU,CAACiF,IAAI,CAACC,CAAC,CAAC,CAAC;IAC3B,IAAItE,CAAC,GAAGZ,UAAU,CAACiF,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC,CAAC;IAC/BvB,MAAM,CAACwB,IAAI,CAAC,CAACxE,CAAC,EAAEC,CAAC,CAAC,CAAC;EACrB;EAEA,OAAO+C,MAAM;AACf;AAEA,IAAIyB,aAAa,GAAG;EAClB,MAAM,EAAE,MAAM;EACd,QAAQ,EAAE,QAAQ;EAClB,cAAc,EAAE,WAAW;EAC3B,SAAS,EAAE,SAAS;EACpB,cAAc,EAAE,aAAa;EAC7B,gBAAgB,EAAE,eAAe;EACjC,kBAAkB,EAAE,UAAU;EAC9B,mBAAmB,EAAE,gBAAgB;EACrC,gBAAgB,EAAE,SAAS;EAC3B,iBAAiB,EAAE,UAAU;EAC7B,mBAAmB,EAAE,YAAY;EACjC,aAAa,EAAE,YAAY;EAC3B,WAAW,EAAE,UAAU;EACvB,YAAY,EAAE,WAAW;EACzB,aAAa,EAAE,YAAY;EAC3B,YAAY,EAAE,WAAW;EACzB,oBAAoB,EAAE;AACxB,CAAC;AAED,SAASjF,eAAeA,CAACoB,OAAO,EAAEE,EAAE,EAAE4D,IAAI,EAAEC,eAAe,EAAE;EAC3D,IAAIC,OAAO,GAAG9D,EAAE,CAACsD,gBAAgB,IAAI,CAAC,CAAC;EACvC,IAAIS,QAAQ,GAAG/D,EAAE,CAACgE,IAAI,KAAK,MAAM,CAAC,CAAC;;EAEnC,IAAIlE,OAAO,CAAC1C,QAAQ,KAAK,CAAC,EAAE;IAC1B6G,uBAAuB,CAACnE,OAAO,EAAEE,EAAE,CAAC;IACpCtD,MAAM,CAACoH,OAAO,EAAEI,mBAAmB,CAACpE,OAAO,CAAC,CAAC;IAE7C,IAAI,CAAC+D,eAAe,EAAE;MACpB,KAAK,IAAIM,WAAW,IAAIR,aAAa,EAAE;QACrC,IAAIA,aAAa,CAACS,cAAc,CAACD,WAAW,CAAC,EAAE;UAC7C,IAAIE,SAAS,GAAGvE,OAAO,CAACzB,YAAY,CAAC8F,WAAW,CAAC;UAEjD,IAAIE,SAAS,IAAI,IAAI,EAAE;YACrBP,OAAO,CAACH,aAAa,CAACQ,WAAW,CAAC,CAAC,GAAGE,SAAS;UACjD;QACF;MACF;IACF;EACF;EAEA,IAAIC,UAAU,GAAGP,QAAQ,GAAG,UAAU,GAAG,MAAM;EAC/C,IAAIQ,YAAY,GAAGR,QAAQ,GAAG,YAAY,GAAG,QAAQ;EACrD/D,EAAE,CAACY,KAAK,GAAGZ,EAAE,CAACY,KAAK,IAAI,IAAIxE,KAAK,EAAE;EAClC,IAAIoI,OAAO,GAAGxE,EAAE,CAACY,KAAK;EACtBkD,OAAO,CAACW,IAAI,IAAI,IAAI,IAAID,OAAO,CAACE,GAAG,CAACJ,UAAU,EAAEK,QAAQ,CAACb,OAAO,CAACW,IAAI,EAAEb,IAAI,CAAC,CAAC;EAC7EE,OAAO,CAACc,MAAM,IAAI,IAAI,IAAIJ,OAAO,CAACE,GAAG,CAACH,YAAY,EAAEI,QAAQ,CAACb,OAAO,CAACc,MAAM,EAAEhB,IAAI,CAAC,CAAC;EACnF/G,IAAI,CAAC,CAAC,WAAW,EAAE,SAAS,EAAE,aAAa,EAAE,eAAe,EAAE,YAAY,EAAE,UAAU,CAAC,EAAE,UAAUgI,QAAQ,EAAE;IAC3G,IAAIC,UAAU,GAAGD,QAAQ,KAAK,WAAW,IAAId,QAAQ,GAAG,iBAAiB,GAAGc,QAAQ;IACpFf,OAAO,CAACe,QAAQ,CAAC,IAAI,IAAI,IAAIL,OAAO,CAACE,GAAG,CAACI,UAAU,EAAEvG,UAAU,CAACuF,OAAO,CAACe,QAAQ,CAAC,CAAC,CAAC;EACrF,CAAC,CAAC;EAEF,IAAI,CAACf,OAAO,CAACiB,YAAY,IAAIjB,OAAO,CAACiB,YAAY,KAAK,MAAM,EAAE;IAC5DjB,OAAO,CAACiB,YAAY,GAAG,YAAY;EACrC;EAEA,IAAIjB,OAAO,CAACiB,YAAY,KAAK,YAAY,EAAE;IACzCjB,OAAO,CAACiB,YAAY,GAAG,QAAQ;EACjC;EAEA,IAAIjB,OAAO,CAACkB,SAAS,KAAK,OAAO,EAAE;IACjClB,OAAO,CAACkB,SAAS,GAAG,MAAM;EAC5B;EAEA,IAAIlB,OAAO,CAACkB,SAAS,KAAK,KAAK,EAAE;IAC/BlB,OAAO,CAACkB,SAAS,GAAG,OAAO;EAC7B;EAEAnI,IAAI,CAAC,CAAC,gBAAgB,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc,CAAC,EAAE,UAAUgI,QAAQ,EAAE;IACxIf,OAAO,CAACe,QAAQ,CAAC,IAAI,IAAI,IAAIL,OAAO,CAACE,GAAG,CAACG,QAAQ,EAAEf,OAAO,CAACe,QAAQ,CAAC,CAAC;EACvE,CAAC,CAAC;EAEF,IAAIf,OAAO,CAACmB,QAAQ,EAAE;IACpBjF,EAAE,CAACY,KAAK,CAACqE,QAAQ,GAAGrI,IAAI,CAACkH,OAAO,CAACmB,QAAQ,CAAC,CAACjG,KAAK,CAAClC,aAAa,CAAC;EACjE;EAEA,IAAI0H,OAAO,CAACD,YAAY,CAAC,IAAIC,OAAO,CAACD,YAAY,CAAC,KAAK,MAAM,EAAE;IAC7D;IACAvE,EAAE,CAACuE,YAAY,CAAC,GAAG,IAAI;EACzB;EAEAvE,EAAE,CAACsD,gBAAgB,GAAGQ,OAAO;AAC/B;AAEA,IAAIoB,QAAQ,GAAG,kBAAkB;AAEjC,SAASP,QAAQA,CAACQ,GAAG,EAAEvB,IAAI,EAAE;EAC3B;EACA;EACA;EACA,IAAIwB,QAAQ,GAAGxB,IAAI,IAAIuB,GAAG,IAAIA,GAAG,CAACE,KAAK,CAACH,QAAQ,CAAC;EAEjD,IAAIE,QAAQ,EAAE;IACZ,IAAIE,GAAG,GAAG1I,IAAI,CAACwI,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAIlF,GAAG,GAAG0D,IAAI,CAAC0B,GAAG,CAAC;IACnB,OAAOpF,GAAG;EACZ;EAEA,OAAOiF,GAAG;AACZ;AAEA,IAAII,cAAc,GAAG,kEAAkE;AAEvF,SAAStB,uBAAuBA,CAACnE,OAAO,EAAE0F,IAAI,EAAE;EAC9C,IAAIC,SAAS,GAAG3F,OAAO,CAACzB,YAAY,CAAC,WAAW,CAAC;EAEjD,IAAIoH,SAAS,EAAE;IACbA,SAAS,GAAGA,SAAS,CAACC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;IACxC,IAAIC,CAAC,GAAG,IAAI;IACZ,IAAIC,YAAY,GAAG,EAAE;IACrBH,SAAS,CAACC,OAAO,CAACH,cAAc,EAAE,UAAUJ,GAAG,EAAEnB,IAAI,EAAE6B,KAAK,EAAE;MAC5DD,YAAY,CAAClC,IAAI,CAACM,IAAI,EAAE6B,KAAK,CAAC;IAChC,CAAC,CAAC;IAEF,KAAK,IAAIpC,CAAC,GAAGmC,YAAY,CAAC3G,MAAM,GAAG,CAAC,EAAEwE,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACnD,IAAIoC,KAAK,GAAGD,YAAY,CAACnC,CAAC,CAAC;MAC3B,IAAIO,IAAI,GAAG4B,YAAY,CAACnC,CAAC,GAAG,CAAC,CAAC;MAC9BkC,CAAC,GAAGA,CAAC,IAAItJ,MAAM,CAACyJ,MAAM,EAAE;MAExB,QAAQ9B,IAAI;QACV,KAAK,WAAW;UACd6B,KAAK,GAAGjJ,IAAI,CAACiJ,KAAK,CAAC,CAAC7G,KAAK,CAAClC,aAAa,CAAC;UACxCT,MAAM,CAAC0J,SAAS,CAACJ,CAAC,EAAEA,CAAC,EAAE,CAACpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEtH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;UACzE;QAEF,KAAK,OAAO;UACVA,KAAK,GAAGjJ,IAAI,CAACiJ,KAAK,CAAC,CAAC7G,KAAK,CAAClC,aAAa,CAAC;UACxCT,MAAM,CAACmD,KAAK,CAACmG,CAAC,EAAEA,CAAC,EAAE,CAACpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEtH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC5E;QAEF,KAAK,QAAQ;UACXA,KAAK,GAAGjJ,IAAI,CAACiJ,KAAK,CAAC,CAAC7G,KAAK,CAAClC,aAAa,CAAC;UACxCT,MAAM,CAAC2J,MAAM,CAACL,CAAC,EAAEA,CAAC,EAAEpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UACzC;QAEF,KAAK,MAAM;UACTA,KAAK,GAAGjJ,IAAI,CAACiJ,KAAK,CAAC,CAAC7G,KAAK,CAAClC,aAAa,CAAC;UACxCmJ,OAAO,CAACC,IAAI,CAAC,qCAAqC,CAAC;UACnD;QAEF,KAAK,QAAQ;UACX,IAAIL,KAAK,GAAGjJ,IAAI,CAACiJ,KAAK,CAAC,CAAC7G,KAAK,CAAClC,aAAa,CAAC;UAC5C6I,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3BF,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3BF,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3BF,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3BF,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3BF,CAAC,CAAC,CAAC,CAAC,GAAGpH,UAAU,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC;UAC3B;MAAM;IAEZ;IAEAL,IAAI,CAACW,iBAAiB,CAACR,CAAC,CAAC;EAC3B;AACF,CAAC,CAAC;;AAGF,IAAIS,UAAU,GAAG,4BAA4B;AAE7C,SAASlC,mBAAmBA,CAACpE,OAAO,EAAE;EACpC,IAAIc,KAAK,GAAGd,OAAO,CAACzB,YAAY,CAAC,OAAO,CAAC;EACzC,IAAIgI,MAAM,GAAG,CAAC,CAAC;EAEf,IAAI,CAACzF,KAAK,EAAE;IACV,OAAOyF,MAAM;EACf;EAEA,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClBF,UAAU,CAACG,SAAS,GAAG,CAAC;EACxB,IAAIC,cAAc;EAElB,OAAO,CAACA,cAAc,GAAGJ,UAAU,CAACK,IAAI,CAAC7F,KAAK,CAAC,KAAK,IAAI,EAAE;IACxD0F,SAAS,CAACE,cAAc,CAAC,CAAC,CAAC,CAAC,GAAGA,cAAc,CAAC,CAAC,CAAC;EAClD;EAEA,KAAK,IAAIrC,WAAW,IAAIR,aAAa,EAAE;IACrC,IAAIA,aAAa,CAACS,cAAc,CAACD,WAAW,CAAC,IAAImC,SAAS,CAACnC,WAAW,CAAC,IAAI,IAAI,EAAE;MAC/EkC,MAAM,CAAC1C,aAAa,CAACQ,WAAW,CAAC,CAAC,GAAGmC,SAAS,CAACnC,WAAW,CAAC;IAC7D;EACF;EAEA,OAAOkC,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASjH,oBAAoBA,CAACP,WAAW,EAAEP,KAAK,EAAEE,MAAM,EAAE;EACxD,IAAIkI,MAAM,GAAGpI,KAAK,GAAGO,WAAW,CAACP,KAAK;EACtC,IAAIqI,MAAM,GAAGnI,MAAM,GAAGK,WAAW,CAACL,MAAM;EACxC,IAAIgB,KAAK,GAAGoH,IAAI,CAACC,GAAG,CAACH,MAAM,EAAEC,MAAM,CAAC,CAAC,CAAC;;EAEtC,IAAIG,YAAY,GAAG,CAACtH,KAAK,EAAEA,KAAK,CAAC;EACjC,IAAIuH,eAAe,GAAG,CAAC,EAAElI,WAAW,CAACK,CAAC,GAAGL,WAAW,CAACP,KAAK,GAAG,CAAC,CAAC,GAAGkB,KAAK,GAAGlB,KAAK,GAAG,CAAC,EAAE,EAAEO,WAAW,CAACM,CAAC,GAAGN,WAAW,CAACL,MAAM,GAAG,CAAC,CAAC,GAAGgB,KAAK,GAAGhB,MAAM,GAAG,CAAC,CAAC;EACpJ,OAAO;IACLgB,KAAK,EAAEsH,YAAY;IACnBpH,QAAQ,EAAEqH;EACZ,CAAC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,QAAQA,CAAChJ,GAAG,EAAEC,GAAG,EAAE;EAC1B,IAAIhB,MAAM,GAAG,IAAIQ,SAAS,EAAE;EAC5B,OAAOR,MAAM,CAACc,KAAK,CAACC,GAAG,EAAEC,GAAG,CAAC;AAC/B;AAEAgJ,OAAO,CAAClK,QAAQ,GAAGA,QAAQ;AAC3BkK,OAAO,CAAC7H,oBAAoB,GAAGA,oBAAoB;AACnD6H,OAAO,CAACD,QAAQ,GAAGA,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}