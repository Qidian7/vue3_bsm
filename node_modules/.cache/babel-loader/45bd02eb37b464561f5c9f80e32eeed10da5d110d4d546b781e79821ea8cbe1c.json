{"ast":null,"code":"var _util = require(\"../../core/util\");\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar textContain = require(\"../../contain/text\");\nvar roundRectHelper = require(\"./roundRect\");\nvar imageHelper = require(\"./image\");\nvar fixShadow = require(\"./fixShadow\");\nvar _constant = require(\"../constant\");\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n  var computedFont = hostEl.__computedFont;\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n  var contentBlock = hostEl.__textCotentBlock;\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n    lineTop += lineHeight;\n  }\n}\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n    ctx.closePath();\n  }\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n    var textOffset = style.textOffset;\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n    return parseFloat(value);\n  }\n  return value;\n}\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;","map":{"version":3,"names":["_util","require","retrieve2","retrieve3","each","normalizeCssArray","isString","isObject","textContain","roundRectHelper","imageHelper","fixShadow","_constant","ContextCachedBy","WILL_BE_RESTORED","DEFAULT_FONT","VALID_TEXT_ALIGN","left","right","center","VALID_TEXT_VERTICAL_ALIGN","top","bottom","middle","SHADOW_STYLE_COMMON_PROPS","_tmpTextPositionResult","_tmpBoxPositionResult","normalizeTextStyle","style","normalizeStyle","rich","font","makeFont","textAlign","textVerticalAlign","textBaseline","textPadding","renderText","hostEl","ctx","text","rect","prevEl","renderRichText","renderPlainText","needDrawBg","needDrawBackground","prevStyle","checkCache","cachedByMe","__attrCachedBy","PLAIN_TEXT","NONE","styleFont","computedFont","__computedFont","__styleFont","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","textWidth","getWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","globalAlpha","opacity","i","length","propItem","styleProp","ctxProp","val","textStrokeWidth","textStrokeWidthPrev","strokeWidthChanged","strokeChanged","textStroke","getStroke","textFill","getFill","lineWidth","strokeStyle","fillStyle","strokeText","fillText","parseRichText","drawRichText","contentWidth","width","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","token","placeToken","x","y","textRotation","origin","textOrigin","height","translate","rotate","tokenStyle","styleName","isLineHolder","textHeight","setCtx","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","buildPath","r","closePath","fillOpacity","originalGlobalAlpha","fill","image","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","strokeOpacity","stroke","out","textPosition","Array","parsePercent","res","calculateTextPosition","textOffset","prop","value","colorStops","maxValue","lastIndexOf","parseFloat","needDrawText","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/zrender/lib/graphic/helper/text.js"],"sourcesContent":["var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\nvar _constant = require(\"../constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}