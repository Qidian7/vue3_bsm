{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar PointerPath = require(\"./PointerPath\");\nvar graphic = require(\"../../util/graphic\");\nvar ChartView = require(\"../../view/Chart\");\nvar _number = require(\"../../util/number\");\nvar parsePercent = _number.parsePercent;\nvar round = _number.round;\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\nfunction formatLabel(label, labelFormatter) {\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label != null ? label : '');\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(label);\n    }\n  }\n  return label;\n}\nvar PI2 = Math.PI * 2;\nvar GaugeView = ChartView.extend({\n  type: 'gauge',\n  render: function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get('axisLine.lineStyle.color');\n    var posInfo = parsePosition(seriesModel, api);\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n  },\n  dispose: function () {},\n  _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var angleRangeSpan = (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n    var axisLineWidth = lineStyleModel.get('width');\n    var showAxis = axisLineModel.get('show');\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      var endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new graphic.Sector({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle(\n      // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'borderWidth', 'borderColor']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n      for (var i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n      return colorList[i - 1][1];\n    };\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n    this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);\n    this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);\n  },\n  _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    for (var i = 0; i <= splitNumber; i++) {\n      var unitX = Math.cos(angle);\n      var unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * r + cx,\n            y1: unitY * r + cy,\n            x2: unitX * (r - splitLineLen) + cx,\n            y2: unitY * (r - splitLineLen) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n        group.add(splitLine);\n      } // Label\n\n      if (labelModel.get('show')) {\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var distance = labelModel.get('distance');\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: graphic.setTextStyle({}, labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',\n            textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            autoColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        for (var j = 0; j <= subSplitNumber; j++) {\n          var unitX = Math.cos(angle);\n          var unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * r + cx,\n              y1: unitY * r + cy,\n              x2: unitX * (r - tickLen) + cx,\n              y2: unitY * (r - tickLen) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n          group.add(tickLine);\n          angle += subStep;\n        }\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  },\n  _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var oldData = this._data;\n    if (!seriesModel.get('pointer.show')) {\n      // Remove old element\n      oldData && oldData.eachItemGraphicEl(function (el) {\n        group.remove(el);\n      });\n      return;\n    }\n    var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n    var angleExtent = [startAngle, endAngle];\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    data.diff(oldData).add(function (idx) {\n      var pointer = new PointerPath({\n        shape: {\n          angle: startAngle\n        }\n      });\n      graphic.initProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(idx, pointer);\n    }).update(function (newIdx, oldIdx) {\n      var pointer = oldData.getItemGraphicEl(oldIdx);\n      graphic.updateProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(newIdx, pointer);\n    }).remove(function (idx) {\n      var pointer = oldData.getItemGraphicEl(idx);\n      group.remove(pointer);\n    }).execute();\n    data.eachItemGraphicEl(function (pointer, idx) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      pointer.setShape({\n        x: posInfo.cx,\n        y: posInfo.cy,\n        width: parsePercent(pointerModel.get('width'), posInfo.r),\n        r: parsePercent(pointerModel.get('length'), posInfo.r)\n      });\n      pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());\n      if (pointer.style.fill === 'auto') {\n        pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n      }\n      graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());\n    });\n    this._data = data;\n  },\n  _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var titleModel = seriesModel.getModel('title');\n    if (titleModel.get('show')) {\n      var offsetCenter = titleModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var minVal = +seriesModel.get('min');\n      var maxVal = +seriesModel.get('max');\n      var value = seriesModel.getData().get(valueDim, 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, titleModel, {\n          x: x,\n          y: y,\n          // FIXME First data name ?\n          text: data.getName(0),\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  },\n  _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var detailModel = seriesModel.getModel('detail');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    if (detailModel.get('show')) {\n      var offsetCenter = detailModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var width = parsePercent(detailModel.get('width'), posInfo.r);\n      var height = parsePercent(detailModel.get('height'), posInfo.r);\n      var data = seriesModel.getData();\n      var value = data.get(data.mapDimension('value'), 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, detailModel, {\n          x: x,\n          y: y,\n          text: formatLabel(\n          // FIXME First data name ?\n          value, detailModel.get('formatter')),\n          textWidth: isNaN(width) ? null : width,\n          textHeight: isNaN(height) ? null : height,\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  }\n});\nvar _default = GaugeView;\nmodule.exports = _default;","map":{"version":3,"names":["PointerPath","require","graphic","ChartView","_number","parsePercent","round","linearMap","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","label","labelFormatter","replace","PI2","PI","GaugeView","extend","type","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","dispose","axisLineModel","getModel","lineStyleModel","clockwise","startAngle","endAngle","angleRangeSpan","prevEndAngle","axisLineWidth","showAxis","i","length","percent","max","sector","Sector","shape","r0","silent","setStyle","fill","getLineStyle","add","getColor","tmp","_renderTicks","_renderPointer","_renderTitle","_renderDetail","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","unitX","cos","unitY","sin","splitLine","Line","x1","y1","x2","y2","style","stroke","distance","autoColor","Text","setTextStyle","text","x","y","textVerticalAlign","textAlign","j","tickLine","oldData","_data","eachItemGraphicEl","el","remove","valueExtent","angleExtent","data","getData","valueDim","mapDimension","diff","idx","pointer","initProps","setItemGraphicEl","update","newIdx","oldIdx","getItemGraphicEl","updateProps","execute","itemModel","getItemModel","pointerModel","setShape","useStyle","getItemStyle","setHoverStyle","titleModel","offsetCenter","value","getName","forceRich","detailModel","textWidth","isNaN","textHeight","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/chart/gauge/GaugeView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar PointerPath = require(\"./PointerPath\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar round = _number.round;\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(label, labelFormatter) {\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label != null ? label : '');\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(label);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\nvar GaugeView = ChartView.extend({\n  type: 'gauge',\n  render: function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get('axisLine.lineStyle.color');\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n  },\n  dispose: function () {},\n  _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var angleRangeSpan = (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n    var axisLineWidth = lineStyleModel.get('width');\n    var showAxis = axisLineModel.get('show');\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      var endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new graphic.Sector({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'borderWidth', 'borderColor']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      for (var i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);\n\n    this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);\n  },\n  _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n\n    for (var i = 0; i <= splitNumber; i++) {\n      var unitX = Math.cos(angle);\n      var unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * r + cx,\n            y1: unitY * r + cy,\n            x2: unitX * (r - splitLineLen) + cx,\n            y2: unitY * (r - splitLineLen) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var distance = labelModel.get('distance');\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: graphic.setTextStyle({}, labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',\n            textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            autoColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        for (var j = 0; j <= subSplitNumber; j++) {\n          var unitX = Math.cos(angle);\n          var unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * r + cx,\n              y1: unitY * r + cy,\n              x2: unitX * (r - tickLen) + cx,\n              y2: unitY * (r - tickLen) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  },\n  _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {\n    var group = this.group;\n    var oldData = this._data;\n\n    if (!seriesModel.get('pointer.show')) {\n      // Remove old element\n      oldData && oldData.eachItemGraphicEl(function (el) {\n        group.remove(el);\n      });\n      return;\n    }\n\n    var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n    var angleExtent = [startAngle, endAngle];\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    data.diff(oldData).add(function (idx) {\n      var pointer = new PointerPath({\n        shape: {\n          angle: startAngle\n        }\n      });\n      graphic.initProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(idx, pointer);\n    }).update(function (newIdx, oldIdx) {\n      var pointer = oldData.getItemGraphicEl(oldIdx);\n      graphic.updateProps(pointer, {\n        shape: {\n          angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)\n        }\n      }, seriesModel);\n      group.add(pointer);\n      data.setItemGraphicEl(newIdx, pointer);\n    }).remove(function (idx) {\n      var pointer = oldData.getItemGraphicEl(idx);\n      group.remove(pointer);\n    }).execute();\n    data.eachItemGraphicEl(function (pointer, idx) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      pointer.setShape({\n        x: posInfo.cx,\n        y: posInfo.cy,\n        width: parsePercent(pointerModel.get('width'), posInfo.r),\n        r: parsePercent(pointerModel.get('length'), posInfo.r)\n      });\n      pointer.useStyle(itemModel.getModel('itemStyle').getItemStyle());\n\n      if (pointer.style.fill === 'auto') {\n        pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n      }\n\n      graphic.setHoverStyle(pointer, itemModel.getModel('emphasis.itemStyle').getItemStyle());\n    });\n    this._data = data;\n  },\n  _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var titleModel = seriesModel.getModel('title');\n\n    if (titleModel.get('show')) {\n      var offsetCenter = titleModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var minVal = +seriesModel.get('min');\n      var maxVal = +seriesModel.get('max');\n      var value = seriesModel.getData().get(valueDim, 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, titleModel, {\n          x: x,\n          y: y,\n          // FIXME First data name ?\n          text: data.getName(0),\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  },\n  _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {\n    var detailModel = seriesModel.getModel('detail');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n\n    if (detailModel.get('show')) {\n      var offsetCenter = detailModel.get('offsetCenter');\n      var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n      var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n      var width = parsePercent(detailModel.get('width'), posInfo.r);\n      var height = parsePercent(detailModel.get('height'), posInfo.r);\n      var data = seriesModel.getData();\n      var value = data.get(data.mapDimension('value'), 0);\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      this.group.add(new graphic.Text({\n        silent: true,\n        style: graphic.setTextStyle({}, detailModel, {\n          x: x,\n          y: y,\n          text: formatLabel( // FIXME First data name ?\n          value, detailModel.get('formatter')),\n          textWidth: isNaN(width) ? null : width,\n          textHeight: isNaN(height) ? null : height,\n          textAlign: 'center',\n          textVerticalAlign: 'middle'\n        }, {\n          autoColor: autoColor,\n          forceRich: true\n        })\n      }));\n    }\n  }\n});\nvar _default = GaugeView;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}