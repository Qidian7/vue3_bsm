{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar graphic = require(\"../../util/graphic\");\nvar textContain = require(\"zrender/lib/contain/text\");\nvar formatUtil = require(\"../../util/format\");\nvar matrix = require(\"zrender/lib/core/matrix\");\nvar axisHelper = require(\"../../coord/axisHelper\");\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      textPadding: paddings,\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel(\n  // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      axisDimension: axis.dim,\n      axisIndex: axis.index,\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;","map":{"version":3,"names":["zrUtil","require","graphic","textContain","formatUtil","matrix","axisHelper","AxisBuilder","buildElStyle","axisPointerModel","axisPointerType","get","styleModel","getModel","style","getLineStyle","fill","getAreaStyle","stroke","buildLabelElOption","elOption","axisModel","api","labelPos","value","text","getValueLabel","axis","ecModel","precision","formatter","labelModel","paddings","normalizeCssArray","font","getFont","textRect","getBoundingRect","position","width","height","align","verticalAlign","confineInContainer","bgColor","label","shape","x","y","r","slice","textFont","textFill","getTextColor","textPosition","textPadding","lineWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","z2","viewWidth","getWidth","viewHeight","getHeight","Math","min","max","seriesDataIndices","opt","scale","parse","getLabel","params","getAxisRawValue","axisDimension","dim","axisIndex","index","seriesData","each","idxItem","series","getSeriesByIndex","seriesIndex","dataIndex","dataIndexInside","dataParams","getDataParams","push","isString","replace","isFunction","getTransformedPosition","layoutInfo","transform","create","rotate","rotation","translate","applyTransform","dataToCoord","labelOffset","labelDirection","labelMargin","buildCartesianSingleLabelElOption","textLayout","innerTextLayout","textAlign","textVerticalAlign","makeLineShape","p1","p2","xDimIndex","x1","y1","x2","y2","makeRectShape","xy","wh","makeSectorShape","cx","cy","r0","startAngle","endAngle","clockwise","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/component/axisPointer/viewHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      textPadding: paddings,\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      axisDimension: axis.dim,\n      axisIndex: axis.index,\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}