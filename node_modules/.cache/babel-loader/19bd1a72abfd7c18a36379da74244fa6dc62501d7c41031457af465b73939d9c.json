{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar numberUtil = require(\"../util/number\");\nvar formatUtil = require(\"../util/format\");\nvar Scale = require(\"./Scale\");\nvar helper = require(\"./helper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n  /**\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\n   * @return {Array.<number>}\n   */\n  getTicks: function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n    var safeLimit = 10000;\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push(roundNumber(niceTickExtent[0] - interval, intervalPrecision));\n      } else {\n        ticks.push(extent[0]);\n      }\n    }\n    var tick = niceTickExtent[0];\n    while (tick <= niceTickExtent[1]) {\n      ticks.push(tick); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n      if (tick === ticks[ticks.length - 1]) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push(roundNumber(lastNiceTick + interval, intervalPrecision));\n      } else {\n        ticks.push(extent[1]);\n      }\n    }\n    return ticks;\n  },\n  /**\n   * @param {number} [splitNumber=5]\n   * @return {Array.<Array.<number>>}\n   */\n  getMinorTicks: function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick - prevTick;\n      var minorInterval = interval / splitNumber;\n      while (count < splitNumber - 1) {\n        var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n        count++;\n      }\n      minorTicks.push(minorTicksGroup);\n    }\n    return minorTicks;\n  },\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n    var precision = opt && opt.precision;\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\nvar _default = IntervalScale;\nmodule.exports = _default;","map":{"version":3,"names":["numberUtil","require","formatUtil","Scale","helper","roundNumber","round","IntervalScale","extend","type","_interval","_intervalPrecision","setExtent","start","end","thisExtent","_extent","isNaN","parseFloat","unionExtent","other","extent","prototype","call","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","expandToNicedExtent","niceTickExtent","intervalPrecision","ticks","safeLimit","push","tick","length","lastNiceTick","getMinorTicks","splitNumber","minorTicks","getExtent","i","nextTick","prevTick","count","minorTicksGroup","minorInterval","minorTick","getLabel","data","opt","precision","getPrecisionSafe","addCommas","niceTicks","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","niceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","create","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/scale/Interval.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\n   * @return {Array.<number>}\n   */\n  getTicks: function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push(roundNumber(niceTickExtent[0] - interval, intervalPrecision));\n      } else {\n        ticks.push(extent[0]);\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push(tick); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1]) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push(roundNumber(lastNiceTick + interval, intervalPrecision));\n      } else {\n        ticks.push(extent[1]);\n      }\n    }\n\n    return ticks;\n  },\n\n  /**\n   * @param {number} [splitNumber=5]\n   * @return {Array.<Array.<number>>}\n   */\n  getMinorTicks: function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick - prevTick;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}