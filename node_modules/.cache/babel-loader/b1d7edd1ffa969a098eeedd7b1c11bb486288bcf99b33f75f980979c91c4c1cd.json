{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\nvar graphic = require(\"../../util/graphic\");\nvar interactionMutex = require(\"./interactionMutex\");\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(pointerHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\nBrushController.prototype = {\n  constructor: BrushController,\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n    return this;\n  },\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n    this._zr.add(thisGroup);\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n    this._zr.remove(this.group);\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n  mountHandlers(zr, controller._handlers);\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  unmountHandlers(zr, controller._handlers);\n  controller._brushType = controller._brushOption = null;\n}\nfunction mountHandlers(zr, handlers) {\n  each(handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n}\nfunction unmountHandlers(zr, handlers) {\n  each(handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n}\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n  return creatingCover;\n}\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n  if (!track.length) {\n    return false;\n  }\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]],\n  // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\nfunction resetCursor(controller, e, localCursorPoint) {\n  if (\n  // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e)) {\n    return;\n  }\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n  currPanel && zr.setCursorStyle('crosshair');\n}\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n  controller._track.push(localCursorPoint.slice());\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n      controller._covers.push(creatingCover);\n    }\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n  return eventParams;\n}\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n  return brushType;\n}\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\nvar _default = BrushController;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Eventful","graphic","interactionMutex","DataDiffer","curry","each","map","mathMin","Math","min","mathMax","max","mathPow","pow","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","e","n","s","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","lineWidth","stroke","fill","transformable","brushMode","removeOnClick","baseUID","BrushController","zr","call","_zr","group","Group","_brushType","_brushOption","_panels","_track","_dragging","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","_handlers","pointerHandlers","handler","eventName","bind","prototype","constructor","enableBrush","brushOption","doDisableBrush","brushType","doEnableBrush","setPanels","panelOpts","length","panels","panelId","clone","mount","opt","enableGlobalPan","thisGroup","add","attr","position","rotation","scale","_transform","getLocalTransform","eachCover","cb","context","updateCovers","brushOptionList","merge","tmpIdPrefix","oldCovers","newCovers","controller","creatingCover","oldGetKey","getKey","addOrUpdate","update","remove","execute","index","id","cover","__brushOption","newIndex","oldIndex","newBrushOption","endCreating","createCover","updateCoverAfterCreation","unmount","clearCovers","dispose","off","mixin","take","mountHandlers","release","unmountHandlers","handlers","on","coverRenderers","updateZ","coverRenderer","getCoverRenderer","updateCoverShape","range","z","traverse","el","z2","updateCommon","getPanelByPoint","localCursorPoint","panel","transform","pn","isTargetByCursor","getPanelByCover","covers","originalLength","trigger","areas","isEnd","shouldShowCover","track","p2","p1","dx","dy","dist","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","Rect","name","style","makeStyle","silent","draggable","cursor","drift","ondragend","opacity","invisible","updateBaseRect","localRange","handleSize","x","y","xa","ya","x2","y2","x2a","y2a","width","height","widtha","heighta","updateRectShape","mainEl","childAt","useStyle","childOfName","globalDir","getGlobalDirection","h","setShape","pointsToRect","clipByPanel","defaults","strokeNoScale","formatRectRange","getTransform","localDirection","split","reverse","join","inverseMap","left","right","top","bottom","transformDirection","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","driftPolygon","point","localD","transformCoordToLocal","localZero","data","clipPath","points","xmin","ymin","xmax","ymax","resetCursor","isOutsideZrArea","currPanel","i","contain","setCursorStyle","preventDefault","rawE","event","mainShapeContain","updateCoverByMouse","thisBrushOption","eventParams","push","slice","determineBrushType","coverBrushOption","getCreatingRange","defaultBrushType","mousedown","handleDragEnd","target","offsetX","offsetY","mousemove","mouseup","getWidth","getHeight","lineX","getLineRenderer","lineY","rect","localTrack","ends","polygon","Polyline","Polygon","xyIndex","otherExtent","getLinearBrushOtherExtent","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/component/helper/BrushController.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(pointerHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  mountHandlers(zr, controller._handlers);\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  unmountHandlers(zr, controller._handlers);\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction mountHandlers(zr, handlers) {\n  each(handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n}\n\nfunction unmountHandlers(zr, handlers) {\n  each(handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  if ( // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e)) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\n\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}