{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar Animator = require(\"../animation/Animator\");\nvar logError = require(\"../core/log\");\nvar _util = require(\"../core/util\");\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\nAnimatable.prototype = {\n  constructor: Animatable,\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n        prop = prop[pathSplitted[i]];\n      }\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n    return animator;\n  },\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n    animators.length = 0;\n    return this;\n  },\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n    callback = easing;\n    easing = 'linear';\n    delay = 0;\n  } // animateTo(target, time, callback);\n  else if (isFunction(delay)) {\n    callback = delay;\n    delay = 0;\n  } // animateTo(target, callback)\n  else if (isFunction(time)) {\n    callback = time;\n    time = 500;\n  } // animateTo(target)\n  else if (!time) {\n    time = 500;\n  } // Stop all previous animations\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n  function done() {\n    count--;\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\nvar _default = Animatable;\nmodule.exports = _default;","map":{"version":3,"names":["Animator","require","logError","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","animateFrom","animatable","reverse","animateToShallow","slice","count","start","source","objShallow","propertyCount","name","hasOwnProperty","setAttrByPath","when","value","attr","props","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/zrender/lib/mixin/Animatable.js"],"sourcesContent":["var Animator = require(\"../animation/Animator\");\n\nvar logError = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}