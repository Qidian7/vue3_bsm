{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar _core = require(\"./core\");\nvar createElement = _core.createElement;\nvar PathProxy = require(\"../core/PathProxy\");\nvar BoundingRect = require(\"../core/BoundingRect\");\nvar matrix = require(\"../core/matrix\");\nvar textContain = require(\"../contain/text\");\nvar textHelper = require(\"../graphic/helper/text\");\nvar Text = require(\"../graphic/Text\");\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n          large = true;\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n    cmdStr && str.push(cmdStr);\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n  return str.join(' ');\n}\nvar svgPath = {};\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n  if (!el.path) {\n    el.createPathProxy();\n  }\n  var path = el.path;\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\nvar svgImage = {};\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n  if (!image) {\n    return;\n  }\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\nvar svgText = {};\nvar _tmpTextHostRect = new BoundingRect();\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\n * @param {module:zrender/Element} el\n * @param {Object|boolean} [hostRect] {x, y, width, height}\n *        If set false, rect text is not used.\n */\n\nvar svgTextDrawRectText = function (el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n    _tmpTextHostRect.applyTransform(elTransform);\n    hostRect = _tmpTextHostRect;\n  }\n  var textSvgEl = el.__textSvgEl;\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n      tspanList.length = nTextLines;\n    }\n  }\n};\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n  var textRotation = style.textRotation;\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\nsvgText.drawRectText = svgTextDrawRectText;\nsvgText.brush = function (el) {\n  var style = el.style;\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;","map":{"version":3,"names":["_core","require","createElement","PathProxy","BoundingRect","matrix","textContain","textHelper","Text","CMD","arrayJoin","Array","prototype","join","NONE","mathRound","Math","round","mathSin","sin","mathCos","cos","PI","PI2","degree","EPSILON","round4","val","isAroundZero","pathHasFill","style","isText","fill","textFill","pathHasStroke","stroke","textStroke","setTransform","svgEl","m","attr","call","el","key","type","setAttribute","attrXLink","setAttributeNS","bindStyle","fillOpacity","opacity","strokeWidth","textStrokeWidth","lineWidth","strokeScale","strokeNoScale","getLineScale","strokeOpacity","lineDash","lineDashOffset","lineCap","lineJoin","miterLimit","pathDataToString","path","str","data","dataLength","len","i","cmd","cmdStr","nData","M","L","Q","C","A","cx","cy","rx","ry","theta","dTheta","psi","clockwise","dThetaPositive","abs","isCircle","unifiedTheta","large","x0","y0","push","x","y","Z","R","w","h","j","svgPath","brush","__svgEl","createPathProxy","__dirtyPath","beginPath","subPixelOptimize","buildPath","shape","pathStr","indexOf","transform","text","svgTextDrawRectText","getBoundingRect","removeOldTextNode","svgImage","image","HTMLImageElement","src","dw","width","dh","height","__imageSrc","svgText","_tmpTextHostRect","_tmpTextBoxPos","_tmpTextTransform","TEXT_ALIGN_TO_ANCHRO","left","right","center","middle","hostRect","elTransform","needTransformTextByHostEl","transformText","__dirty","normalizeTextStyle","needDrawText","copy","applyTransform","textSvgEl","__textSvgEl","textSvgElStyle","font","DEFAULT_FONT","computedFont","__computedFont","__styleFont","textPadding","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","lineHeight","getBoxPosition","baseX","baseY","textAlign","textVerticalAlign","setTextTransform","boxY","adjustTextY","textX","textY","getTextXForPadding","canCacheByTextString","tspanList","__tspanList","tspanOriginLen","length","__canCacheByTextString","__text","idx","updateTextLocation","textLines","lines","nTextLines","tspan","singleLineText","appendChild","document","createTextNode","__zrText","innerHTML","removeChild","identity","textRotation","origin","textOrigin","rotate","parentNode","drawRectText","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/zrender/lib/svg/graphic.js"],"sourcesContent":["var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar Text = require(\"../graphic/Text\");\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\n * @param {module:zrender/Element} el\n * @param {Object|boolean} [hostRect] {x, y, width, height}\n *        If set false, rect text is not used.\n */\n\nvar svgTextDrawRectText = function (el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}