{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar colorUtil = require(\"zrender/lib/tool/color\");\nvar List = require(\"../../data/List\");\nvar numberUtil = require(\"../../util/number\");\nvar graphic = require(\"../../util/graphic\");\nvar markerHelper = require(\"./markerHelper\");\nvar MarkerView = require(\"./MarkerView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO Better on polar\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  var lt = markerHelper.dataTransform(seriesModel, item[0]);\n  var rb = markerHelper.dataTransform(seriesModel, item[1]);\n  var retrieve = zrUtil.retrieve; // FIXME make sure lt is less than rb\n\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n  ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n  rbCoord[0] = retrieve(rbCoord[0], Infinity);\n  rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one\n\n  var result = zrUtil.mergeAll([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markArea has one dim\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n}\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n  if (coordSys.type === 'cartesian2d') {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n  return markerHelper.dataFilter(coordSys, {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  }) || markerHelper.dataFilter(coordSys, {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  });\n} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      if (isInifinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInifinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n  return point;\n}\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\nMarkerView.extend({\n  type: 'markArea',\n  // updateLayout: function (markAreaModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var maModel = seriesModel.markAreaModel;\n  //         if (maModel) {\n  //             var areaData = maModel.getData();\n  //             areaData.each(function (idx) {\n  //                 var points = zrUtil.map(dimPermutations, function (dim) {\n  //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n  //                 });\n  //                 // Layout\n  //                 areaData.setItemLayout(idx, points);\n  //                 var el = areaData.getItemGraphicEl(idx);\n  //                 el.setShape('points', points);\n  //             });\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = seriesModel.markAreaModel;\n      if (maModel) {\n        var areaData = maModel.getData();\n        areaData.each(function (idx) {\n          var points = zrUtil.map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n          }); // Layout\n\n          areaData.setItemLayout(idx, points);\n          var el = areaData.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new graphic.Group()\n    });\n    this.group.add(polygonGroup.group);\n    polygonGroup.__keep = true;\n    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter\n\n    maModel.setData(areaData); // Update visual and layout of line\n\n    areaData.each(function (idx) {\n      // Layout\n      var points = zrUtil.map(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      }); // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n\n      var allClipped = true;\n      zrUtil.each(dimPermutations, function (dim) {\n        if (!allClipped) {\n          return;\n        }\n        var xValue = areaData.get(dim[0], idx);\n        var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped\n\n        if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {\n          allClipped = false;\n        }\n      });\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      }); // Visual\n\n      areaData.setItemVisual(idx, {\n        color: seriesData.getVisual('color')\n      });\n    });\n    areaData.diff(polygonGroup.__data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n      if (!layout.allClipped) {\n        var polygon = new graphic.Polygon({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n      var layout = areaData.getItemLayout(newIdx);\n      if (!layout.allClipped) {\n        if (polygon) {\n          graphic.updateProps(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new graphic.Polygon({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var labelModel = itemModel.getModel('label');\n      var labelHoverModel = itemModel.getModel('emphasis.label');\n      var color = areaData.getItemVisual(idx, 'color');\n      polygon.useStyle(zrUtil.defaults(itemModel.getModel('itemStyle').getItemStyle(), {\n        fill: colorUtil.modifyAlpha(color, 0.4),\n        stroke: color\n      }));\n      polygon.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n      graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        isRectText: true,\n        autoColor: color\n      });\n      graphic.setHoverStyle(polygon, {});\n      polygon.dataModel = maModel;\n    });\n    polygonGroup.__data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\nfunction createList(coordSys, seriesModel, maModel) {\n  var coordDimsInfos;\n  var areaData;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n    areaData = new List(zrUtil.map(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos[idx % 2].type\n      };\n    }), maModel);\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new List(coordDimsInfos, maModel);\n  }\n  var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));\n  }\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n  } : function (item) {\n    return item.value;\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}","map":{"version":3,"names":["zrUtil","require","colorUtil","List","numberUtil","graphic","markerHelper","MarkerView","markAreaTransform","seriesModel","coordSys","maModel","item","lt","dataTransform","rb","retrieve","ltCoord","coord","rbCoord","Infinity","result","mergeAll","x0","x","y0","y","x1","y1","isInifinity","val","isNaN","isFinite","ifMarkLineHasOnlyDim","dimIndex","fromCoord","toCoord","otherDimIndex","markAreaFilter","type","dataFilter","getSingleMarkerEndPoint","data","idx","dims","api","coordinateSystem","itemModel","getItemModel","point","xPx","parsePercent","get","getWidth","yPx","getHeight","getMarkerPosition","getValues","pt","clampData","dataToPoint","xAxis","getAxis","yAxis","toGlobalCoord","getExtent","dimPermutations","extend","updateTransform","markAreaModel","ecModel","eachSeries","areaData","getData","each","points","map","dim","setItemLayout","el","getItemGraphicEl","setShape","renderSeries","seriesId","id","seriesData","areaGroupMap","markerGroupMap","polygonGroup","set","group","Group","add","__keep","createList","setData","allClipped","xValue","yValue","containData","setItemVisual","color","getVisual","diff","__data","layout","getItemLayout","polygon","Polygon","shape","setItemGraphicEl","update","newIdx","oldIdx","updateProps","remove","execute","eachItemGraphicEl","labelModel","getModel","labelHoverModel","getItemVisual","useStyle","defaults","getItemStyle","fill","modifyAlpha","stroke","hoverStyle","setLabelStyle","style","labelFetcher","labelDataIndex","defaultText","getName","isRectText","autoColor","setHoverStyle","dataModel","silent","coordDimsInfos","dimensions","coordDim","info","getDimensionInfo","mapDimension","name","optData","curry","filter","dimValueGetter","dimName","dataIndex","Math","floor","value","initData","hasItemOption"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/component/marker/MarkAreaView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar colorUtil = require(\"zrender/lib/tool/color\");\n\nvar List = require(\"../../data/List\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar MarkerView = require(\"./MarkerView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO Better on polar\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  var lt = markerHelper.dataTransform(seriesModel, item[0]);\n  var rb = markerHelper.dataTransform(seriesModel, item[1]);\n  var retrieve = zrUtil.retrieve; // FIXME make sure lt is less than rb\n\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n  ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n  rbCoord[0] = retrieve(rbCoord[0], Infinity);\n  rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one\n\n  var result = zrUtil.mergeAll([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\n\nfunction isInifinity(val) {\n  return !isNaN(val) && !isFinite(val);\n} // If a markArea has one dim\n\n\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n}\n\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n\n  if (coordSys.type === 'cartesian2d') {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n\n  return markerHelper.dataFilter(coordSys, {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  }) || markerHelper.dataFilter(coordSys, {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  });\n} // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\n\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n  var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n\n    if (coordSys.type === 'cartesian2d') {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n\n      if (isInifinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInifinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n\n  return point;\n}\n\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\nMarkerView.extend({\n  type: 'markArea',\n  // updateLayout: function (markAreaModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var maModel = seriesModel.markAreaModel;\n  //         if (maModel) {\n  //             var areaData = maModel.getData();\n  //             areaData.each(function (idx) {\n  //                 var points = zrUtil.map(dimPermutations, function (dim) {\n  //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n  //                 });\n  //                 // Layout\n  //                 areaData.setItemLayout(idx, points);\n  //                 var el = areaData.getItemGraphicEl(idx);\n  //                 el.setShape('points', points);\n  //             });\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = seriesModel.markAreaModel;\n\n      if (maModel) {\n        var areaData = maModel.getData();\n        areaData.each(function (idx) {\n          var points = zrUtil.map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n          }); // Layout\n\n          areaData.setItemLayout(idx, points);\n          var el = areaData.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new graphic.Group()\n    });\n    this.group.add(polygonGroup.group);\n    polygonGroup.__keep = true;\n    var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter\n\n    maModel.setData(areaData); // Update visual and layout of line\n\n    areaData.each(function (idx) {\n      // Layout\n      var points = zrUtil.map(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      }); // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n\n      var allClipped = true;\n      zrUtil.each(dimPermutations, function (dim) {\n        if (!allClipped) {\n          return;\n        }\n\n        var xValue = areaData.get(dim[0], idx);\n        var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped\n\n        if ((isInifinity(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis('y').containData(yValue))) {\n          allClipped = false;\n        }\n      });\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      }); // Visual\n\n      areaData.setItemVisual(idx, {\n        color: seriesData.getVisual('color')\n      });\n    });\n    areaData.diff(polygonGroup.__data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n\n      if (!layout.allClipped) {\n        var polygon = new graphic.Polygon({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n\n      var layout = areaData.getItemLayout(newIdx);\n\n      if (!layout.allClipped) {\n        if (polygon) {\n          graphic.updateProps(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new graphic.Polygon({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var labelModel = itemModel.getModel('label');\n      var labelHoverModel = itemModel.getModel('emphasis.label');\n      var color = areaData.getItemVisual(idx, 'color');\n      polygon.useStyle(zrUtil.defaults(itemModel.getModel('itemStyle').getItemStyle(), {\n        fill: colorUtil.modifyAlpha(color, 0.4),\n        stroke: color\n      }));\n      polygon.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n      graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        isRectText: true,\n        autoColor: color\n      });\n      graphic.setHoverStyle(polygon, {});\n      polygon.dataModel = maModel;\n    });\n    polygonGroup.__data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\nfunction createList(coordSys, seriesModel, maModel) {\n  var coordDimsInfos;\n  var areaData;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n    areaData = new List(zrUtil.map(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos[idx % 2].type\n      };\n    }), maModel);\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new List(coordDimsInfos, maModel);\n  }\n\n  var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));\n\n  if (coordSys) {\n    optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));\n  }\n\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n  } : function (item) {\n    return item.value;\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}