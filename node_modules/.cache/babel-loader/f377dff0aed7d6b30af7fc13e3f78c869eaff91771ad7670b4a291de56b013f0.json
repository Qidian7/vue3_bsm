{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar numberUtil = require(\"../../util/number\");\nvar helper = require(\"./helper\");\nvar sliderMove = require(\"../helper/sliderMove\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  },\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n    // `calculateDataWindow` uses min/maxSpan.\n\n    setMinMaxSpan(this);\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    setAxisModel(this);\n  },\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n      if (!dataDims.length) {\n        return;\n      }\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n  var max = axisModel.getMax(true);\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n  return dataExtent;\n}\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  var dataExtent = axisProxy._dataExtent;\n  each(['min', 'max'], function (minMax) {\n    var percentSpan = dataZoomModel.get(minMax + 'Span');\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n    valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    if (valueSpan != null) {\n      percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n    } else if (percentSpan != null) {\n      valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n    }\n    minMaxSpan[minMax + 'Span'] = percentSpan;\n    minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n  });\n}\nvar _default = AxisProxy;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","numberUtil","helper","sliderMove","each","asc","AxisProxy","dimName","axisIndex","dataZoomModel","ecModel","_dimName","_axisIndex","_valueWindow","_percentWindow","_dataExtent","_minMaxSpan","_dataZoomModel","prototype","constructor","hostedBy","getDataValueWindow","slice","getDataPercentWindow","getTargetSeriesModels","seriesModels","eachSeries","seriesModel","isCoordSupported","get","axisModel","queryComponents","mainType","index","id","componentIndex","push","getAxisModel","getComponent","getOtherAxisModel","axisDim","isCartesian","otherAxisDim","coordSysIndexName","foundOtherAxisModel","eachComponent","otherAxisModel","getMinMaxSpan","clone","calculateDataWindow","opt","dataExtent","scale","axis","rangePropMode","getRangePropMode","percentExtent","percentWindow","valueWindow","hasPropModeValue","prop","idx","boundPercent","boundValue","parse","linearMap","spans","restrictSet","fromWindow","toWindow","fromExtent","toExtent","toValue","suffix","i","reset","targetSeries","calculateDataExtent","setMinMaxSpan","dataWindow","settledOption","setAxisModel","restore","filterData","api","filterMode","seriesData","getData","dataDims","mapDimension","length","filterSelf","dataIndex","leftOut","rightOut","hasValue","value","thisHasValue","isNaN","thisLeftOut","thisRightOut","dim","setData","map","isInWindow","NaN","range","selectRange","setApproximateExtent","axisProxy","Infinity","seriesExtent","getApproximateExtent","fixExtentByAxis","min","getMin","isCategoryAxis","axisDataLen","getCategories","max","getMax","isRestore","precision","getPixelPrecision","Math","useOrigin","setRange","toFixed","minMaxSpan","minMax","percentSpan","valueSpan","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value']; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n    // `calculateDataWindow` uses min/maxSpan.\n\n    setMinMaxSpan(this);\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  var dataExtent = axisProxy._dataExtent;\n  each(['min', 'max'], function (minMax) {\n    var percentSpan = dataZoomModel.get(minMax + 'Span');\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n    valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    if (valueSpan != null) {\n      percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n    } else if (percentSpan != null) {\n      valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n    }\n\n    minMaxSpan[minMax + 'Span'] = percentSpan;\n    minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}