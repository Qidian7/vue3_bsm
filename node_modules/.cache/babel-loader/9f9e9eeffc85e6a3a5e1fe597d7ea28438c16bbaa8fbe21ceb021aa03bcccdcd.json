{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\nvar __DEV__ = _config.__DEV__;\nvar _util = require(\"zrender/lib/core/util\");\nvar each = _util.each;\nvar filter = _util.filter;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar indexOf = _util.indexOf;\nvar isObject = _util.isObject;\nvar isString = _util.isString;\nvar createHashMap = _util.createHashMap;\nvar assert = _util.assert;\nvar clone = _util.clone;\nvar merge = _util.merge;\nvar extend = _util.extend;\nvar mixin = _util.mixin;\nvar modelUtil = require(\"../util/model\");\nvar Model = require(\"./Model\");\nvar ComponentModel = require(\"./Component\");\nvar globalDefault = require(\"./globalDefault\");\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n    this.resetOption(null);\n  },\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n      optionChanged = true;\n    }\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n    return optionChanged;\n  },\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = [];\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCptTypes.push(mainType);\n      }\n    });\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        createSeriesIndices(this, componentsMap.get('series'));\n      }\n    }\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\n  },\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n    if (!mainType) {\n      return [];\n    }\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n    var cpts = this._componentsMap.get(mainType);\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n    var result;\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n    return filterBySubType(result, condition);\n  },\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   *\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n  /**\n   * @return {number}\n   */\n  getSeriesCount: function () {\n    return this._componentsMap.get('series').length;\n  },\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @param {string} subType.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  },\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    createSeriesIndices(this, filteredSeries);\n  },\n  restoreData: function (payload) {\n    var componentsMap = this._componentsMap;\n    createSeriesIndices(this, componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\n      });\n    });\n  }\n});\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seiresIndex;\n    var id = payload.seriesId;\n    var name = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\n  }\n}\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices;\n  this._seriesIndicesMap;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!isArray(types)) {\n    types = types ? [types] : [];\n  }\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\nfunction createSeriesIndices(ecModel, seriesModels) {\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || []);\n}\n/**\n * @inner\n */\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\nfunction assertSeriesInitialized(ecModel) {}\nmixin(GlobalModel, colorPaletteMixin);\nvar _default = GlobalModel;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","_util","each","filter","map","isArray","indexOf","isObject","isString","createHashMap","assert","clone","merge","extend","mixin","modelUtil","Model","ComponentModel","globalDefault","colorPaletteMixin","_sourceHelper","resetSourceDefaulter","OPTION_INNER_KEY","GlobalModel","init","option","parentModel","theme","optionManager","_theme","_optionManager","setOption","optionPreprocessorFuncs","resetOption","type","optionChanged","baseOption","mountOption","initBase","call","restoreData","mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","_api","length","mediaOption","newOption","componentsMap","_componentsMap","newCptTypes","componentOption","mainType","hasClass","push","topologicalTravel","getAllClassMainTypes","visitComponent","dependencies","newCptOptionList","normalizeToArray","mapResult","mappingToExists","get","makeIdAndName","item","index","opt","keyInfo","subType","determineSubType","exist","dependentModels","getComponentsByTypes","set","resultItem","componentModel","newCptOption","optionUpdated","ComponentModelClass","getClass","constructor","name","extraOpt","componentIndex","createSeriesIndices","_seriesIndicesMap","_seriesIndices","getOption","opts","i","isIdInner","splice","getTheme","getComponent","idx","list","queryComponents","condition","id","cpts","result","val","isIdArray","cpt","isNameArray","slice","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","components","componentType","component","queryResult","getSeriesByName","series","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","assertSeriesInitialized","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","getCurrentSeriesIndices","filterSeries","filteredSeries","payload","componentTypes","isNotTargetSeries","seiresIndex","seriesId","seriesName","mergeTheme","notMergeColorLayer","color","colorLayer","themeItem","types","ret","existComponent","ecModel","seriesModels","hasOwnProperty","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/echarts/lib/model/Global.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar filter = _util.filter;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar indexOf = _util.indexOf;\nvar isObject = _util.isObject;\nvar isString = _util.isString;\nvar createHashMap = _util.createHashMap;\nvar assert = _util.assert;\nvar clone = _util.clone;\nvar merge = _util.merge;\nvar extend = _util.extend;\nvar mixin = _util.mixin;\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\n\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\n\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = [];\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCptTypes.push(mainType);\n      }\n    });\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        createSeriesIndices(this, componentsMap.get('series'));\n      }\n    }\n\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   *\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * @return {number}\n   */\n  getSeriesCount: function () {\n    return this._componentsMap.get('series').length;\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @param {string} subType.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    createSeriesIndices(this, filteredSeries);\n  },\n  restoreData: function (payload) {\n    var componentsMap = this._componentsMap;\n    createSeriesIndices(this, componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\n      });\n    });\n  }\n});\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seiresIndex;\n    var id = payload.seriesId;\n    var name = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\n  }\n}\n/**\n * @inner\n */\n\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices;\n  this._seriesIndicesMap;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(ecModel, seriesModels) {\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || []);\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nmixin(GlobalModel, colorPaletteMixin);\nvar _default = GlobalModel;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}