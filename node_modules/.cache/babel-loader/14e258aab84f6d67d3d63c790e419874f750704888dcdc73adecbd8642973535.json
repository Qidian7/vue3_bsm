{"ast":null,"code":"var Displayable = require(\"./Displayable\");\nvar zrUtil = require(\"../core/util\");\nvar PathProxy = require(\"../core/PathProxy\");\nvar pathContain = require(\"../contain/path\");\nvar Pattern = require(\"./Pattern\");\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n    if (needsUpdateRect) {\n      var path = this.path;\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n      rect = path.getBoundingRect();\n    }\n    this._rect = rect;\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n      return rectWithStroke;\n    }\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n    return false;\n  },\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n      this.dirty(true);\n    }\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n    var defaultShape = defaults.shape;\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n    defaults.init && defaults.init.call(this, opts);\n  };\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n  return Sub;\n};\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;","map":{"version":3,"names":["Displayable","require","zrUtil","PathProxy","pathContain","Pattern","getCanvasPattern","prototype","abs","Math","pathProxyForDraw","Path","opts","call","path","constructor","type","__dirtyPath","strokeContainThreshold","segmentIgnoreThreshold","subPixelOptimize","brush","ctx","prevEl","style","hasStroke","hasFill","fill","stroke","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","image","hasStrokePattern","bind","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","fillOpacity","originalGlobalAlpha","globalAlpha","opacity","strokeOpacity","text","restoreTransform","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","clone","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","max","width","height","x","y","contain","localPos","transformCoordToLocal","pathData","data","containStroke","dirty","dirtyPath","__dirtyText","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","key","value","setShape","isObject","name","hasOwnProperty","m","transform","sqrt","extend","defaults","Sub","extendFrom","defaultShape","thisShape","init","inherits","_default","module","exports"],"sources":["/Users/mac/Desktop/vue_bsm/vue3_bsm/node_modules/zrender/lib/graphic/Path.js"],"sourcesContent":["var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}